<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8">
<style>

body {
    font: sans-serif;
}

.graph_container {
    float: left;
}

.node circle {
    stroke: #000;
    stroke-width: 1.5px;
    fill: #000;
}

.node {
    font: 10px sans-serif;
}

.link {
    fill: none;
    stroke: #000;
    stroke-width: 1.5px;
}

#inputWindowParameters {
	position: fixed;
	right: 30px;
	top: 30px;
}

#lambda_text{
	background-color: rgba(192,192,192,.7);
}
</style>

</head>
<body>

<div>
	<div id="inputWindowParameters">
    <div><a href="graph.html">graph</a></div>
    <div>
        navigate:
        <input type="button" onclick="shift_window(-1)"
        value="<" />
        <input type="button" onclick="shift_window(1)"
        value=">" />
        window size: <input id="window_size" maxlength="3"
        size="3" type="text" onchange="update_window_size()" />
    </div>
    <div id="status">
        showing subgraphs <span id="window_start_text"></span> to
        <span id="window_end_text"></span> of <span
            id="num_graphs_text"></span>
    </div>
    <div id="showCounts">
        <label for="showValues">show counts: </label><input type="checkbox"
        onchange="update_graphs();" id="showValues"/>
    </div>
	</div>
</div>

<div id="graphs_container">
</div>

<script src="d3.v3.js"></script>

<script src="core.js"></script>

<script>
$window_size = 5;
$window_start = 0;
$num_windows = 0;
$num_graphs = 0;

node_size = function(d) {
    return d.active ? Math.min(Math.log(d.lambda_ss+1),10): 2;
}

set_node_text = function(node, text) {
    new_child = document.createTextNode(text);
    while (node.hasChildNodes()) {
        node.removeChild(node.firstChild);
    }
    node.appendChild(new_child);
}

add_lambda_ss_text = function(font_size){
	return function(d){ return d.active ?
		"<div id=\"lambda_text\" style=\"font-size: " + font_size +"px\">"
			+ Math.round(10000*d.lambda_ss)/10000 + "</div>"
		: "" ;
	}
}

format_words = function(d) {
    var graph_node = lookup_node($graph_root, d.node_placement);
    s = "";
    for (w in graph_node.words) {
        if (w > 0) {
            s += " ";
        }
        s += graph_node.words[w]['word'];
    }
    return s;
}

update_nav_text = function() {
    set_node_text(document.getElementById("window_start_text"), $window_start);
    set_node_text(document.getElementById("window_end_text"), $window_end);
    set_node_text(document.getElementById("num_graphs_text"), $num_graphs);
}

compare_int_arrays = function(array1, array2){
	var equal = true;
	if(array1 != null && array2 != null){
		if(array1.length == array2.length){
			for(index = 0; index < array1.length; index++){
				if(array1[index] != array2[index]){
					equal = false;
				}
			}
		}else{
			equal = false;
		}
	}else{
		equal = false;
	}
	return equal;
}

index_in_array = function(innerArray, outerArray){
	var index_in_array = -1;
	for(arrayx = 0; arrayx < outerArray.length; arrayx++){
		if(compare_int_arrays(innerArray, outerArray[arrayx]) == true){
			index_in_array = arrayx;
			break;
		}
	}
	return index_in_array;
}

node_sort_array = [];

filter_node_first = function(node){
	var end_sort = $root.length;
	var root_index = 0;
	if(node != null){
		if(index_in_array(node.node_placement, node_sort_array) == -1){
			node_sort_array[node_sort_array.length] = node.node_placement;
			for(graphNum = 0; graphNum < $root.length; graphNum++){
				lookup_node($root[graphNum]["subtree"], node.node_placement).circled = true;
			}
		}else{
			var indexOfNode = index_in_array(node.node_placement, node_sort_array);
			node_sort_array.splice(indexOfNode,1);
			for(graphNum = 0; graphNum < $root.length; graphNum++){
				lookup_node($root[graphNum]["subtree"], node.node_placement).circled = false;
			}
			filter_node_first(null);
		}
	}
	for(CirNode = 0; CirNode < node_sort_array.length; CirNode++){
		for(graphNum = 0; graphNum < end_sort; graphNum++){
			if(lookup_node($root[graphNum]["subtree"], node_sort_array[CirNode]).active == true){
				var temp = $root[graphNum];
				$root[graphNum] = $root[root_index];
				$root[root_index] = temp;
				root_index++;
			}
		}
		end_sort = root_index;
		root_index = 0;
	}
	update_graphs();
	
}

update_graphs = function() {
    update_nav_text();

    graphs_container = document.getElementById("graphs_container");
    while (graphs_container.hasChildNodes()) {
        graphs_container.removeChild(graphs_container.firstChild);
    }

    var stringColor =
    d3.scale.linear().domain([0,-1*minELogPi]).range(["red","blue"]);

    for (var c = $window_start; c < $window_end; ++c) {
        var cluster = d3.layout.cluster()

        .size([$height , $width - 14*maxNodeSize]);

        var graph_container = document.createElement("div");
        graph_container.className = "graph_container";
        graphs_container.appendChild(graph_container);

        var user = $root[c]["user"];
        var user_container = document.createElement("div");
        user_container.className = "user";
        graph_container.appendChild(user_container);
        var user_text = document.createTextNode(user);
        user_container.appendChild(user_text);

        var inner_graph_container = document.createElement("div");
        graph_container.appendChild(inner_graph_container);

        var svg = d3.select(inner_graph_container).append("svg")
        .attr("width", $width)
        .attr("height", $height)
        .append("g")
        .attr("transform", "translate("+ 2.5*(maxNodeSize+1) +",0)");

        var nodes = cluster.nodes($root[c]["subtree"]);
        var links = cluster.links(nodes);

        var link = svg.selectAll(".link")
        .data(links)
        .enter().append("path")
        .attr("class", "link")
        .attr("d", diagonal)
        .style("stroke-opacity", function(d) { return d.target.active ?
               "1" : "0.1"; });

        var node = svg.selectAll(".node")
        .data(nodes)
        .enter().append("g")
        .attr("class", "node")
        .attr("transform", function(d) { return "translate(" +
              d.y + "," + d.x + ")"; });

        node.append("circle")
        .attr("r", function(d) { return node_size(d); })
        .style("fill", function(d) {return d.active ?
               stringColor(d.Elogpi*-1) : "black"})
        .style("stroke", function(d) {return d.active ?
               stringColor(d.Elogpi*-1) : "black"})
        .style("stroke-opacity", function(d) { return d.active ?
               (0.1 + 0.9*(d.Elogpi-minELogPi)/(minELogPi*-1)) : "0.05"; })
        .style("fill-opacity", function(d) { return d.active ?
               (0.1 + 0.9*(d.Elogpi-minELogPi)/(minELogPi*-1)) : "0.05"; });

        node.append("circle")
        .attr("r", maxNodeSize)
        .style("fill", "black")
        .style("stroke", "black")
        .style("stroke-opacity", function(d){return d.active ? (d.circled? "1":"0"): "0"})
        .style("fill-opacity", "0")
		.on("click", function(d){filter_node_first(d)})
        .append("title")
        .text(format_words);

        if(document.getElementById("showValues").checked == true){
			node.append("foreignObject")
				.attr("width", 80)
				.attr("height", 30)
				.append("xhtml:body")
				.html(add_lambda_ss_text(10));
        }
    }
}

update_window_size = function() {
    $window_size = parseInt(document.getElementById("window_size").value, 10);
    $num_windows = Math.ceil($num_graphs / $window_size);
    $window_end = Math.min($window_start + $window_size, $num_graphs);
    update_graphs();
}

shift_window = function(delta) {
    $window_start += delta * $window_size;
    if ($window_start < 0) {
        $window_start = 0;
    } else if ($window_start >= $num_graphs) {
        $window_start = ($num_windows - 1) * $window_size;
    }
    $window_end = Math.min($window_start + $window_size, $num_graphs);
    update_graphs();
}

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; })
    .source(function (d) {
        var s = Object.create(d.source);
        s.y += node_size(s);
        return s;
    })
    .target(function (d) {
        var t = Object.create(d.target);
        t.y -= node_size(t);
        return t;
    });

tree_depth = function(node) {
    var depth = 0;
    for (var c in node.children) {
        child = node.children[c];
        depth = Math.max(depth, 1 + tree_depth(child));
    }
    return depth;
}

tree_size = function(node) {
    var size = 1;
    for (var c in node.children) {
        child = node.children[c];
        size += tree_size(child);
    }
    return size;
}

tree_size_per_level = function(node) {
    var sizes = [1];
    for (var c in node.children) {
        child = node.children[c];
        var c_sizes = tree_size_per_level(child);
        for (var j = 0; j < sizes.length - 1 && j < c_sizes.length; ++j) {
            sizes[j+1] += c_sizes[j];
        }
        for (var j = sizes.length - 1; j < c_sizes.length; ++j) {
            sizes.push(c_sizes[j]);
        }
    }
    return sizes;
}

lookup_node = function(subtree, placement) {
    return lookup_node_helper(subtree, placement.slice(1));
}

lookup_node_helper = function(node, placement) {
    if (placement.length == 0) {
        return node;
    } else {
        return lookup_node_helper(node.children[placement[0]], placement.slice(1));
    }
}

d3.json("graph.json", function(error, graph_root) {
    $graph_root = graph_root;
    d3.json("subgraphs.json", function(error, root) {
        $num_graphs = root.length;
        $root = root;

        minimum_ELogPi_rootParent = function(min_var_param, root, paramName){
        min_var_param = 0;
        for(indiv = 0; indiv < $num_graphs; indiv++){
            minSubStat = minimum_ELogPi_subtreeChildren(min_var_param, root[indiv]["subtree"], paramName);
            if(minSubStat<min_var_param){
                min_var_param = minSubStat;
            }
        }
        return min_var_param;
        }

        minimum_ELogPi_subtreeChildren = function(min_var_param, node, paramName){
            if(min_var_param > node[paramName]){
                min_var_param = node[paramName];
            }
            for (var c in node.children) {
                child = node.children[c];
                min_var_param = minimum_ELogPi_subtreeChildren(min_var_param, child, paramName);
            }
            return min_var_param;
        }

        maximum_Node_Size_rootParent = function(min_var_param, root){
            min_var_param = 0;
            for(indiv = 0; indiv < $num_graphs; indiv++){
                minSubStat = maximum_Node_Size_subtreeChildren(min_var_param, root[indiv]["subtree"]);
                if(minSubStat>min_var_param){
                    min_var_param = minSubStat;
                }
            }
            return min_var_param;
        }

        maximum_Node_Size_subtreeChildren = function(min_var_param, node){
            if(min_var_param < node_size(node)){
                min_var_param = node_size(node);
            }
            for (var c in node.children) {
                child = node.children[c];
                min_var_param = maximum_Node_Size_subtreeChildren(min_var_param, child);
            }
            return min_var_param;
        }

        node_placement_rootParent = function(){
        for(graphNum = 0; graphNum < $root.length; graphNum++){
            node_placement_subtreeChildren($root[graphNum].subtree, 0, []);
        }
    }

        node_placement_subtreeChildren = function(node, placementInList, currentArray){
            var myArray = [];
            for(k = 0; k < currentArray.length; k++){
                myArray[k] = currentArray[k];
            }
            myArray[myArray.length] = placementInList;
            node.node_placement = myArray;

            for(var c in node.children){
                child = node.children[c];
                node_placement_subtreeChildren(child, c, myArray);
            }
        }

        node_placement_rootParent();
        maxNodeSize = 0;
        maxNodeSize = maximum_Node_Size_rootParent(maxNodeSize, $root);
        minELogPi = 0;
        minELogPi = minimum_ELogPi_rootParent(minELogPi, $root, "Elogpi");

        $width = maxNodeSize * 16 * (tree_depth(root[0]["subtree"])+1) + maxNodeSize;
        $height = maxNodeSize * 2.5 * Math.max.apply(null,
                                      tree_size_per_level(root[0]["subtree"]));

        document.getElementById("window_size").value = $window_size;
        update_window_size();

        d3.select(self.frameElement).style("height", $height + "px");
    });
});

</script>

</body>
</html>
