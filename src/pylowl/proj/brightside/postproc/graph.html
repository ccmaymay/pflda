<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8">
<style>

body {
  font: sans-serif;
}

.node circle {
  fill: #fff;
  stroke: #000;
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

.node {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #000;
  stroke-opacity: 0.2;
  stroke-width: 1.5px;
}

#lambda_text {
    border: 1px solid black;
	background-color: rgba(255,255,255, .85);
    display: inline-block;
    padding: 2px;
}

#showCounts {
    border: 1px solid black;
	position: fixed;
	right: 0;
	top: 0;
    background-color: rgba(255,255,255,.85);
    padding: 10px;
}
</style>

</head>
<body>

<div id="showCounts">
    <div><a href="subgraphs.html">subgraphs</a></div>
    <label for="showValues">show counts: </label><input type="checkbox" onchange="update_graph();" id="showValues"/>
</div>
<div id="graphs_container">
</div>

<script src="d3.v3.js"></script>

<script src="core.js"></script>

<script>
var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; })
    .source(function (d) {
        var s = Object.create(d.source);
        s.y += node_size(s);
        return s;
    })
    .target(function (d) {
        var t = Object.create(d.target);
        t.y -= node_size(t);
        return t;
    });

make_format_words = function(min_font, font_exp_scale) {
    return function(d) {
        var s = "<div>";
        for (var j = 0; j < 10; j++) {
            var word = d.words[j].word;
            var weight = d.words[j].lambda_ss;
            if (j > 0) { s += " "; }
            s += "<span style=\"font-size: " + Math.max(min_font,
                                                        font_exp_scale*Math.log(weight)/Math.log(2)) + "px\">" + word +
        "</span>";
        }
        s += "</div>";
        return s;
    }
}

lambda_ss_sum = function(node){
	var s = 0;
	for(word = 0; word < node.words.length; word++){
		s += node.words[word].lambda_ss;
	}
	return s;
}

node_size = function(node){
    return Math.max(Math.min(Math.log(lambda_ss_sum(node)),40),0)+2;
}

add_lambda_ss_text = function(font_size){
	return function(d){ return "<div id=\"lambda_text\" style=\"font-size: " + font_size +"px\">" + Math.round(1000*lambda_ss_sum(d))/1000 + "</div>";
	}
}

update_graph = function() {
	var ramp =
    d3.scale.linear().domain([$minELogPi,$maxELogPi]).range(["blue","red"]);
	
    var graphs_container = document.getElementById("graphs_container");
    while (graphs_container.hasChildNodes()) {
        graphs_container.removeChild(graphs_container.firstChild);
    }

    var cluster = d3.layout.cluster()
    .size([$height, $width - 300]);

    var svg = d3.select("#graphs_container").append("svg")
    .attr("width", $width)
    .attr("height", $height)
    .append("g")
    .attr("transform", "translate(20,0)");

    var nodes = cluster.nodes($root),
    links = cluster.links(nodes);

    var link = svg.selectAll(".link")
    .data(links)
    .enter().append("path")
    .attr("class", "link")
    .attr("d", diagonal);

    var node = svg.selectAll(".node")
    .data(nodes)
    .enter().append("g")
    .attr("class", "node")
    .attr("transform", function(d) { return "translate(" + d.y +
          "," + d.x + ")"; })

    node.append("foreignObject")
    .attr("width", 200)
    .attr("height", 140)
    .append("xhtml:body")
    .html(make_format_words(6, 2));

	node.append("circle")
		.attr("r", function(d){return node_size(d);})
		.style("fill", function(d) {return ramp(d.Elogpi);})
        .style("stroke", function(d) {return ramp(d.Elogpi);})
        .style("stroke-opacity", function(d) { return 0.1 + 0.9*(d.Elogpi-$minELogPi)/($maxELogPi-$minELogPi);})
        .style("fill-opacity", function(d) { return 0.1 + 0.9*(d.Elogpi-$minELogPi)/($maxELogPi-$minELogPi);});

    if(document.getElementById("showValues").checked == true){
		node.append("foreignObject")
		.attr("width", 200)
		.attr("height", 30)
		.attr("y", -20)
		.append("xhtml:body")
		.html(add_lambda_ss_text(10));
    }
}

tree_depth = function(node) {
    var depth = 0;
    for (var c in node.children) {
        var child = node.children[c];
        depth = Math.max(depth, 1 + tree_depth(child));
    }
    return depth;
}


tree_size = function(node) {
    var size = 1;
    for (var c in node.children) {
        var child = node.children[c];
        size += tree_size(child);
    }
    return size;
}

tree_size_per_level = function(node) {
    var sizes = [1];
    for (var c in node.children) {
        var child = node.children[c];
        var c_sizes = tree_size_per_level(child);
        for (var j = 0; j < sizes.length - 1 && j < c_sizes.length; ++j) {
            sizes[j+1] += c_sizes[j];
        }
        for (var j = sizes.length - 1; j < c_sizes.length; ++j) {
            sizes.push(c_sizes[j]);
        }
    }
    return sizes;
}

d3.json("graph.json", function(error, root) {
    $root = root;

	$maxNodeSize = null;
	$maxNodeSize = maximum_Node_Size_subtreeChildren($maxNodeSize, $root)
    $minELogPi = null;
    $minELogPi = minimum_param_subtreeChildren($minELogPi, $root, "Elogpi");
    $maxELogPi = null;
    $maxELogPi = maximum_param_subtreeChildren($maxELogPi, $root, "Elogpi");

    $width = 300 * tree_depth(root) + 300;
    $height = 140 * Math.max.apply(null, tree_size_per_level(root));

    update_graph();

    d3.select(self.frameElement).style("height", $height + "px");
});

</script>

</body>
</html>
